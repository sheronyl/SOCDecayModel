---
title: "Five pool model fitting: Fixed Initial Input"
author: "S. Y. Luk (sheronyl@mit.edu) and K. Todd-Brown (ktoddbrown@gmail.com)"
date: "8/7/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup}
#install necessary packages ["tidyverse","readxl","deSolve","GGally","tidyr","dplyr"]

rm(list=ls())
library(tidyverse)
library(readxl)
library(deSolve)
library(GGally)
library(tidyr)
library(dplyr)
library(mmc)
library(SimDesign)

#set data directory with data file
dataDir <- '/Users/SheronLuk/Documents/GitHub/DecayModeling/Rmd Final/6GITHUB'
setwd(dataDir)
```

```{r readData}
#Load data file
data.df<- read.csv(file="TwoPoolDataFinal.csv",  skipNul= TRUE)
#Rename headers
names(data.df) <- c('time','C1','C2','ID','REP')
#Order by time
data.df<-data.df[order(data.df$time),]
```

```{r modelFunc with inputs}
NPoolModel_modInput.fn <- function(t, y, parms, ...){
  #for linear fit I_max+(-I_max/root_time)*t
  dy <- ifelse(t < parms$root_time, parms$I_max-parms$I_max/parms$root_time*t, 0) + 
    parms$decay %*% y[1:nrow(parms$decay)]
  return(list(c(dy)))
}
```

```{r fitFirstPool}
#Generate combination of parameters for model to run through: decay rate (k), starting_C (x0), transfer (r), input (I0), over input time within rooting zone defined as 85 years 
firstPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=10),
                              starting_C = seq(75, 140, by=1),
                              r=0,
                              input=seq(0, 3, by=0.5),
                              inputtime=85 #years for 25cm root depth
                              )) %>%
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=xx$input, root_time=xx$inputtime, decay = matrix(-xx$decay_rates), transfer = xx$r)) %>%
      as.data.frame %>% 
      mutate(C_data = data.df$C1, ID=data.df$ID, REP=data.df$REP)%>%
      ungroup()%>%
      dplyr::select(C,C_data,ID,REP) %>%
      do((function(x){
      data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),
                 broom::tidy(lm(x$C_data ~ x$C)))
      })(.))
  })(.)) %>%
  #Filter acceptable model fits based on linear regression of observed and modeled output. Good fit is whether intercept+/-SE overlap 0 and slope+/- overlap 1.
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 ) 

set.seed(123)
#Filter based on lowest quartile RMSE
firstPool.parm <- firstPool %>% 
  filter(RMSE<summary(firstPool$RMSE)[[2]]) %>%
  dplyr::select(r, decay_rates, starting_C, input,inputtime,RMSE) %>% 
  unique() %>% ungroup() %>%
  mutate(C1_index = 1:nrow(.)) %>%
  dplyr::rename('C1_r' = 'r','C1_decay' = 'decay_rates', 'C1_0' = 'starting_C', 'C1_in' = 'input','C1_inputtime'='inputtime','C1_RMSE'='RMSE') %>%
  #Random sampling of 50 inclusive of the minimum RMSE model run
  sample_n(50)

#Add RMSE minimum 
firstPool.parm<-rbind(firstPool.parm[firstPool.parm$C1_RMSE == min(firstPool.parm$C1_RMSE),],firstPool.parm) %>%
  unique()%>%
  mutate(C1_index = 1:nrow(.))
```

```{r fit2ndpool}

secondPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=50),
                              starting_C = seq(20, 50, by=1),
                              input=seq(0, 3, by=0.5), 
                              inputtime=85, #years for 25cm root depth
                              r = seq(0,1, by=0.5),
                              C1_index = firstPool.parm$C1_index)) %>% 
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = firstPool.parm$C1_0[xx$C1_index], C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(firstPool.parm$C1_in[xx$C1_index], xx$input), 
                       root_time=c(firstPool.parm$C1_inputtime[xx$C1_index], xx$inputtime),  
                       decay = matrix(c(-firstPool.parm$C1_decay[xx$C1_index], 0,
                      firstPool.parm$C1_decay[xx$C1_index]*xx$r,-xx$decay_rates), nrow = 2, byrow = TRUE))) %>%
          as.data.frame %>% 
          mutate(C_data = data.df$C2, ID=data.df$ID, REP=data.df$REP) %>%
          ungroup()%>%
          dplyr::select(C,C_data,ID,REP)%>%
          do((function(x){
          data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),
                 broom::tidy(lm(x$C_data ~ x$C)))
          })(.))
  })(.)) %>% 
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 ) 

set.seed(123)
secondPool.parm <- secondPool %>% 
  filter(RMSE<summary(secondPool$RMSE)[[2]]) %>% 
  ungroup() %>%
  dplyr::select(r,decay_rates,starting_C,input,inputtime,RMSE,C1_index) %>% 
  unique() %>% 
  rename('C2_r'='r','C2_decay' = 'decay_rates', 'C2_0' = 'starting_C', 'C2_in' = 'input', 'C2_inputtime' = 'inputtime','C2_RMSE'='RMSE') %>%
  left_join(firstPool.parm) %>%
  sample_n(50)

secondPool.parm<-rbind(secondPool.parm[secondPool.parm$C2_RMSE == min(secondPool.parm$C2_RMSE),],secondPool.parm) %>%
  unique()%>%
  mutate(C2_index = 1:nrow(.))

save.image(file="FirstSecondPool.Rdata")

```

```{r modelDataPlot}
#run simulation of all good model fits
simulations <- secondPool.parm %>% 
  full_join(firstPool.parm) %>% ungroup() %>% 
  mutate(index = 1:nrow(.)) %>%
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = firstPool.parm$C1_0[xx$C1_index], C2=xx$C2_0), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(firstPool.parm$C1_in[xx$C1_index], xx$C2_in), 
                       root_time=c(firstPool.parm$C1_inputtime[xx$C1_index], xx$C2_inputtime), 
                       decay = matrix(c(-firstPool.parm$C1_decay[xx$C1_index], 0,
                       firstPool.parm$C1_decay[xx$C1_index]*xx$C2_r,-xx$C2_decay), nrow = 2, byrow = TRUE))) %>%
      as.data.frame
  })(.))

#select best fit model based on minimizing sum of RMSE
secondPool.parm$sumRMSE<-secondPool.parm$C1_RMSE+secondPool.parm$C2_RMSE
bestFitfinal<-secondPool.parm[secondPool.parm$sumRMSE==min(secondPool.parm$sumRMSE),]

bestfitsimulations <- bestFitfinal %>% 
  left_join(firstPool.parm) %>% ungroup() %>% 
  mutate(index = 1:nrow(.)) %>%
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = xx$C1_0, C2=xx$C2_0), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(xx$C1_in, xx$C2_in), 
                       root_time=c(xx$C1_inputtime, xx$C2_inputtime), 
                       decay = matrix(c(-xx$C1_decay, 0,
                       xx$C1_decay*xx$C2_r,-xx$C2_decay), nrow = 2, byrow = TRUE))) %>%
      as.data.frame
  })(.))
write.csv(bestfitsimulations, file="TwoPoolBestFit.csv")

```

```{r plot}
ggplot(data.df %>% pivot_longer(cols = c('C1','C2'), names_to = 'pool'),
       aes(x=time, y=value))+
  geom_line(data = simulations %>% ungroup() %>% dplyr::select(index, time,C1,C2) %>%
              pivot_longer(cols = c('C1','C2'), names_to = 'pool'),
            aes(x=time, y=value, color = pool, group=paste(index, pool)), alpha = 0.1) +
  
     geom_line(data = bestfitsimulations %>% ungroup() %>% dplyr::select(index, time, C1, C2) %>%
              pivot_longer(cols = c('C1','C2'), names_to = 'pool'),
            aes(x=time, y=value, color = 'Best Fit', group=paste(index, pool)), alpha = 1, lwd=2) +
  
  geom_point() +
  xlab('Time') + ylab("CO2 Evolved (mg C"  ~ g^{-1} ~ "dry sediment)") +
  theme_bw() +
  facet_wrap(~pool)
```

```{r summary table}
ranges<-data.frame(matrix(ncol = 3, nrow =8))
for (i in 1:4){
ranges[i,]<-c(min(firstPool.parm[,i]),max(firstPool.parm[,i]),firstPool.parm[bestfitsimulations$C1_index,i])
ranges[i+4,]<-c(min(secondPool.parm[,i]),max(secondPool.parm[,i]),secondPool.parm[bestfitsimulations$C2_index,i])
}
rownames(ranges)<-c('r1','k1','x01','input1','r2','k2','x02','input2')
colnames(ranges)<-c('min','max','bestfit')
options(scipen=999)
print(ranges)

#write.csv(ranges, file="TwoPoolBestFitRanges1208.csv")
#changed file name for consistency
write.csv(ranges, file="TwoPoolBestFitRanges.csv")
```