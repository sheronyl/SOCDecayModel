---
title: "Five pool model fitting: Fixed Initial Input"
author: "K Todd-Brown (ktoddbrown@gmail.com)"
date: "8/7/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup}
#install necessary packages ["tidyverse","readxl","deSolve","GGally","tidyr","dplyr"]

rm(list=ls())
library(tidyverse)
library(readxl)
library(deSolve)
library(GGally)
library(tidyr)
library(dplyr)
library(mmc)
library(SimDesign)

#set data directory with data file
dataDir <- '/Users/SheronLuk/Documents/GitHub/DecayModeling/Rmd Final/6GITHUB'
setwd(dataDir)
```

```{r readData}
#Load data file
data.df<- read.csv(file="FivePoolDataFinal.csv",  skipNul= TRUE)
#Rename headers
names(data.df) <- c('time','C1','C2','C3','C4','C5','ID','REP')
#Order by time
data.df<-data.df[order(data.df$time),]
```

```{r modelFunc with inputs}
NPoolModel_modInput.fn <- function(t, y, parms, ...){
  #for linear fit I_max+(-I_max/root_time)*t
  dy <- ifelse(t < parms$root_time, parms$I_max-parms$I_max/parms$root_time*t, 0) + 
    parms$decay %*% y[1:nrow(parms$decay)]
  return(list(c(dy)))
}
```

```{r fitFirstPool}
#Generate combination of parameters for model to run through: decay rate (k), starting_C (x0), transfer (r), input (I0), over input time within rooting zone defined as 85 years 
firstPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=10),
                              starting_C = seq(49, 55, by=1),
                              r=0,
                              input=seq(0, 3, by=0.5),
                              inputtime=85 #years for 25cm root depth
                              )) %>%
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=xx$input, root_time=xx$inputtime, decay = matrix(-xx$decay_rates), transfer = xx$r)) %>%
      as.data.frame %>% 
      mutate(C_data = data.df$C1, ID=data.df$ID, REP=data.df$REP) %>%
      ungroup()%>%
      dplyr::select(C,C_data,ID,REP) %>%
      do((function(x){
      data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),
                 broom::tidy(lm(x$C_data ~ x$C)))
      })(.))
  })(.)) %>%
#Filter acceptable model fits based on linear regression of observed and modeled output. Good fit is whether intercept+/-SE overlap 0 and slope+/- overlap 1.
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 ) 

set.seed(123)
#Filter based on lowest quartile RMSE
firstPool.parm <- firstPool %>% 
  filter(RMSE<summary(firstPool$RMSE)[[2]]) %>%
  dplyr::select(r, decay_rates, starting_C, input,inputtime,RMSE) %>% 
  unique() %>% ungroup() %>%
  dplyr::rename('C1_r' = 'r','C1_decay' = 'decay_rates', 'C1_0' = 'starting_C', 'C1_in' = 'input','C1_inputtime'='inputtime','C1_RMSE'='RMSE') %>%
  #Random sampling of 50 inclusive of the minimum RMSE model run
  sample_n(50)

#Add RMSE minimum 
firstPool.parm<-rbind(firstPool.parm[firstPool.parm$C1_RMSE == min(firstPool.parm$C1_RMSE),],firstPool.parm) %>%
  unique()%>%
  mutate(C1_index = 1:nrow(.))
```

```{r fit2ndpool}
secondPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=50),
                              starting_C = seq(35, 50, by=1),
                              input=seq(0, 3, by=0.5), 
                              inputtime=85, #years for 25cm root depth
                              r = seq(0,1, by=0.5),
                              C1_index = firstPool.parm$C1_index)) %>% 
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = firstPool.parm$C1_0[xx$C1_index], C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(firstPool.parm$C1_in[xx$C1_index], xx$input), 
                       root_time=c(firstPool.parm$C1_inputtime[xx$C1_index], xx$inputtime),  
                       decay = matrix(c(-firstPool.parm$C1_decay[xx$C1_index], 0,
                      firstPool.parm$C1_decay[xx$C1_index]*xx$r,-xx$decay_rates), nrow = 2, byrow = TRUE))) %>%
          as.data.frame %>% 
          mutate(C_data = data.df$C2, ID=data.df$ID, REP=data.df$REP) %>%
          ungroup()%>%
          dplyr::select(C,C_data,ID,REP)%>%
          do((function(x){
          data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),
                 broom::tidy(lm(x$C_data ~ x$C)))
          })(.))
  })(.)) %>% 
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 )

set.seed(123)
secondPool.parm <- secondPool %>% 
  filter(RMSE<summary(secondPool$RMSE)[[2]]) %>% 
  ungroup() %>%
  dplyr::select(r,decay_rates,starting_C,input,inputtime,RMSE,C1_index) %>% 
  unique() %>% 
  rename('C2_r'='r','C2_decay' = 'decay_rates', 'C2_0' = 'starting_C', 'C2_in' = 'input', 'C2_inputtime' = 'inputtime','C2_RMSE'='RMSE') %>%
  left_join(firstPool.parm) %>%
  sample_n(50)

secondPool.parm<-rbind(secondPool.parm[secondPool.parm$C2_RMSE == min(secondPool.parm$C2_RMSE),],secondPool.parm) %>%
  unique()%>%
  mutate(C2_index = 1:nrow(.))

save.image(file="FirstSecondPool.Rdata")
rm("firstPool","firstPool.parm","secondPool")
```

```{r fit3rdpool}
thirdPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=50), #100
                              starting_C =  seq(19,22, by=1),
                              r = seq(0,1, by=0.5),
                              input=seq(0, 3, by=0.5), #0.5
                              inputtime=85, #years for 25cm root depth
                              C2_index = secondPool.parm$C2_index)) %>% 
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = secondPool.parm$C1_0[xx$C2_index], C2 = secondPool.parm$C2_0[xx$C2_index], C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(secondPool.parm$C1_in[xx$C2_index], secondPool.parm$C2_in[xx$C2_index], xx$input), 
                       root_time=c(secondPool.parm$C1_inputtime[xx$C2_index],
                                   secondPool.parm$C2_inputtime[xx$C2_index], xx$inputtime),  
                       decay = matrix(c(-secondPool.parm$C1_decay[xx$C2_index],0,0,
                                        secondPool.parm$C1_decay[xx$C2_index]*secondPool.parm$C2_r[xx$C2_index],-secondPool.parm$C2_decay[xx$C2_index],0,
                                        0,secondPool.parm$C2_decay[xx$C2_index]*xx$r,-xx$decay_rates), nrow = 3, byrow = TRUE))) %>%
          as.data.frame %>% 
          mutate(C_data = data.df$C3, ID=data.df$ID, REP=data.df$REP) %>%
          ungroup()%>%
          dplyr::select(C,C_data,ID,REP)%>%
          do((function(x){
          data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),broom::tidy(lm(x$C_data ~ x$C)))
          })(.))
  })(.)) %>% 
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 )

set.seed(123)
thirdPool.parm <- thirdPool %>% 
  filter(RMSE<summary(thirdPool$RMSE)[[2]]) %>% 
  ungroup() %>%
  dplyr::select(r,decay_rates,starting_C,input,inputtime,RMSE,C2_index) %>% 
  unique() %>% 
  dplyr::rename('C3_r'= 'r','C3_decay' = 'decay_rates', 'C3_0' = 'starting_C', 'C3_in' = 'input', 'C3_inputtime' = 'inputtime','C3_RMSE'='RMSE') %>%
  left_join(secondPool.parm) %>%
  sample_n(50)

thirdPool.parm<-rbind(thirdPool.parm[thirdPool.parm$C3_RMSE == min(thirdPool.parm$C3_RMSE),],thirdPool.parm) %>%
  unique()%>%
  mutate(C3_index = 1:nrow(.))

save.image(file="ThirdPool.Rdata")
rm("secondPool.parm","thirdPool")

```

```{r fit4thpool}
#load("SYL0317ThirdPool.Rdata")

fourthPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=50),
                              starting_C =  seq(12, 15, by=1),
                              r = seq(0,1, by=0.5),
                              input=seq(0, 3, by=0.5),
                              inputtime=85, #years for 25cm root depth
                              C3_index = thirdPool.parm$C3_index))%>% 
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = thirdPool.parm$C1_0[xx$C3_index], C2 = thirdPool.parm$C2_0[xx$C3_index], C3 = thirdPool.parm$C3_0[xx$C3_index], C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(thirdPool.parm$C1_in[xx$C3_index],thirdPool.parm$C2_in[xx$C3_index],thirdPool.parm$C3_in[xx$C3_index], xx$input), 
                       root_time=c(thirdPool.parm$C1_inputtime[xx$C3_index],thirdPool.parm$C2_inputtime[xx$C3_index],thirdPool.parm$C3_inputtime[xx$C3_index], xx$inputtime),  
                       decay = matrix(c(-thirdPool.parm$C1_decay[xx$C3_index],0,0,0,
                                        thirdPool.parm$C1_decay[xx$C3_index]*thirdPool.parm$C2_r[xx$C3_index],-thirdPool.parm$C2_decay[xx$C3_index],0,0,
                                        0,thirdPool.parm$C2_decay[xx$C3_index]*thirdPool.parm$C3_r[xx$C3_index],-thirdPool.parm$C3_decay[xx$C3_index],0,
                                        0,0,thirdPool.parm$C3_decay[xx$C3_index]*xx$r,-xx$decay_rates), nrow = 4, byrow = TRUE))) %>%
          as.data.frame %>% 
          mutate(C_data = data.df$C4, ID=data.df$ID, REP=data.df$REP) %>%
          ungroup()%>%
          dplyr::select(C,C_data,ID,REP)%>%
          do((function(x){
          data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),broom::tidy(lm(x$C_data ~ x$C)))
          })(.))
  })(.)) %>% 
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 ) 

set.seed(123)
fourthPool.parm <- fourthPool %>% 
  filter(RMSE<summary(fourthPool$RMSE)[[2]]) %>% 
  ungroup() %>%
  dplyr::select(r,decay_rates,starting_C,input,inputtime,RMSE,C3_index) %>% 
  unique() %>% 
  dplyr::rename('C4_r'= 'r','C4_decay' = 'decay_rates', 'C4_0' = 'starting_C', 'C4_in' = 'input', 'C4_inputtime' = 'inputtime','C4_RMSE'='RMSE') %>%
  left_join(thirdPool.parm) %>%
  sample_n(50)

fourthPool.parm<-rbind(fourthPool.parm[fourthPool.parm$C4_RMSE == min(fourthPool.parm$C4_RMSE),],fourthPool.parm) %>%
  unique()%>%
  mutate(C4_index = 1:nrow(.))

save.image(file="FourthPool.Rdata")
rm("thirdPool.parm","fourthPool")


```

```{r fit5thpool}
#randomly sample and also select min max of input and decay.

fifthPool <- expand.grid(list(decay_rates = 1/seq(0.5, 10000, by=50),
                              starting_C =  seq(13, 15, by=1),
                              r = seq(0,1, by=0.5),
                              input=seq(0, 3, by=0.5), 
                              inputtime=85, #years for 25cm root depth
                              C4_index = fourthPool.parm$C4_index)) %>% 
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = fourthPool.parm$C1_0[xx$C4_index], C2 = fourthPool.parm$C2_0[xx$C4_index], C3 = fourthPool.parm$C3_0[xx$C4_index], C4 = fourthPool.parm$C4_0[xx$C4_index], C=xx$starting_C), 
          times = data.df$time, 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(fourthPool.parm$C1_in[xx$C4_index], fourthPool.parm$C2_in[xx$C4_index], fourthPool.parm$C3_in[xx$C4_index], fourthPool.parm$C4_in[xx$C4_index], xx$input), 
                       root_time=c(fourthPool.parm$C1_inputtime[xx$C4_index],fourthPool.parm$C2_inputtime[xx$C4_index],fourthPool.parm$C3_inputtime[xx$C4_index],fourthPool.parm$C4_inputtime[xx$C4_index], xx$inputtime),  
                       decay = matrix(c(-fourthPool.parm$C1_decay[xx$C4_index],0,0,0,0,
                                        fourthPool.parm$C1_decay[xx$C4_index]*fourthPool.parm$C2_r[xx$C4_index],-fourthPool.parm$C2_decay[xx$C4_index],0,0,0,
                                        0,fourthPool.parm$C2_decay[xx$C4_index]*fourthPool.parm$C3_r[xx$C4_index],-fourthPool.parm$C3_decay[xx$C4_index],0,0,
                                        0,0,fourthPool.parm$C3_decay[xx$C4_index]*fourthPool.parm$C4_r[xx$C4_index],-fourthPool.parm$C4_decay[xx$C4_index],0,
                                        0,0,0,fourthPool.parm$C4_decay[xx$C4_index]*xx$r,-xx$decay_rates), nrow = 5, byrow = TRUE))) %>%
      as.data.frame %>% 
      mutate(C_data = data.df$C5, ID=data.df$ID, REP=data.df$REP) %>%
      ungroup()%>%
      dplyr::select(C,C_data,ID,REP)%>%
      do((function(x){
      data.frame(RMSE=sqrt(sum((x$C-x$C_data)^2)/length(x$C_data)),broom::tidy(lm(x$C_data ~ x$C)))
      })(.))
  })(.)) %>% 
  filter(estimate[term == '(Intercept)'] - std.error[term == '(Intercept)'] < 0 &
                       estimate[term == '(Intercept)'] + std.error[term == '(Intercept)'] > 0) %>%
  filter(estimate[term == 'x$C'] - std.error[term == 'x$C'] < 1 &
           estimate[term == 'x$C'] + std.error[term == 'x$C'] > 1 ) 

set.seed(123)
fifthPool.parm <- fifthPool %>% 
  filter(RMSE<summary(fifthPool$RMSE)[[2]]) %>% 
  ungroup() %>%
  dplyr::select(r,decay_rates,starting_C,input,inputtime,RMSE,C4_index) %>% 
  unique() %>% 
  mutate(C5_index = 1:nrow(.)) %>%
  dplyr::rename('C5_r'= 'r','C5_decay' = 'decay_rates', 'C5_0' = 'starting_C', 'C5_in' = 'input', 'C5_inputtime' = 'inputtime','C5_RMSE'='RMSE') %>%
  left_join(fourthPool.parm)

save.image(file="FifthPool.Rdata")
```

```{r Best Fit Model Simulation}
#select best fit model based on minimizing sum of RMSE
fifthPool.parm$sumRMSE<-fifthPool.parm$C1_RMSE+fifthPool.parm$C2_RMSE+fifthPool.parm$C3_RMSE+fifthPool.parm$C4_RMSE+fifthPool.parm$C5_RMSE
bestFitfinal<-fifthPool.parm[fifthPool.parm$sumRMSE==min(fifthPool.parm$sumRMSE),]
#run simulation
bestfitsimulations <- bestFitfinal %>% 
  ungroup()%>%
  mutate(index = 1:nrow(.)) %>%
  group_by_all() %>%
  do((function(xx){
    lsoda(y=c(C1 = xx$C1_0, C2=xx$C2_0, C3=xx$C3_0, C4=xx$C4_0, C5=xx$C5_0), 
          times =  c(seq(0,1000, by=20)), 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(xx$C1_in, xx$C2_in, xx$C3_in, xx$C4_in, xx$C5_in), 
                       root_time=c(xx$C1_inputtime, xx$C2_inputtime, xx$C3_inputtime, xx$C4_inputtime, xx$C5_inputtime), 
                       decay = matrix(c(-xx$C1_decay, 0, 0, 0, 0,
                                      xx$C1_decay*xx$C2_r,-xx$C2_decay,0,0,0,
                                      0,xx$C2_decay*xx$C3_r,-xx$C3_decay,0,0,
                                      0,0,xx$C3_decay*xx$C4_r,-xx$C4_decay,0,
                                      0,0,0,xx$C4_decay*xx$C5_r,-xx$C5_decay), nrow = 5, byrow = TRUE))) %>%
      as.data.frame
  })(.))
```

```{r modelDataPlot}
#run simulation of all good model fits
simulations <- fifthPool.parm %>% 
  ungroup() %>% 
  mutate(index = 1:nrow(.)) %>%
  group_by_all() %>%
  do((function(xx){
        lsoda(y=c(C1 = xx$C1_0, C2=xx$C2_0, C3=xx$C3_0, C4=xx$C4_0, C5=xx$C5_0), 
          times = c(seq(0,1000, by=20)), 
          func = NPoolModel_modInput.fn,
          parms = list(I_max=c(xx$C1_in, xx$C2_in, xx$C3_in, xx$C4_in, xx$C5_in), 
                       root_time=c(xx$C1_inputtime, xx$C2_inputtime, xx$C3_inputtime, xx$C4_inputtime, xx$C5_inputtime), 
                       decay = matrix(c(-xx$C1_decay, 0, 0, 0, 0,
                                      xx$C1_decay*xx$C2_r,-xx$C2_decay,0,0,0,
                                      0,xx$C2_decay*xx$C3_r,-xx$C3_decay,0,0,
                                      0,0,xx$C3_decay*xx$C4_r,-xx$C4_decay,0,
                                      0,0,0,xx$C4_decay*xx$C5_r,-xx$C5_decay), nrow = 5, byrow = TRUE)))%>%
      as.data.frame
  })(.))

write.csv(bestfitsimulations, file="FivePoolBestFit.csv")
```

```{r plot best and good fit models}
ggplot(data.df %>% pivot_longer(cols = c('C1','C2','C3','C4','C5'), names_to = 'pool'),
       aes(x=time, y=value))+
  
  geom_line(data = simulations %>% ungroup() %>% dplyr::select(index, time, C1, C2, C3, C4, C5) %>%
              pivot_longer(cols = c('C1','C2','C3','C4','C5'), names_to = 'pool'),
            aes(x=time, y=value, color = pool, group=paste(index, pool)), alpha = 0.5) +
  
      geom_line(data = bestfitsimulations %>% ungroup() %>% dplyr::select(index, time, C1,C2,C3,C4,C5) %>%
              pivot_longer(cols = c('C1','C2','C3','C4','C5'), names_to = 'pool'),
            aes(x=time, y=value, color = 'Best Fit', group=paste(index, pool)), alpha = 1, lwd=2) +
  geom_point() +
  xlab('Time') + ylab("CO2 Evolved (mg C"  ~ g^{-1} ~ "dry sediment)") +
  theme_bw() +
  facet_wrap(~pool)
```

```{r create summary table}
load("SYLFirstSecondPool.Rdata")
load("SYLThirdPool.Rdata")
load("SYLFourthPool.Rdata")
load("SYLFourthPool.Rdata")
load("SYLFifthPool.Rdata")

ranges<-data.frame(matrix(ncol = 3, nrow =20))
for (i in 1:4){
ranges[i,]<-c(min(firstPool.parm[,i]),max(firstPool.parm[,i]),firstPool.parm[bestFitfinal$C1_index,i])
ranges[i+4,]<-c(min(secondPool.parm[,i]),max(secondPool.parm[,i]),secondPool.parm[bestFitfinal$C2_index,i])
ranges[i+8,]<-c(min(thirdPool.parm[,i]),max(thirdPool.parm[,i]),thirdPool.parm[bestFitfinal$C3_index,i])
ranges[i+12,]<-c(min(fourthPool.parm[,i]),max(fourthPool.parm[,i]),fourthPool.parm[bestFitfinal$C4_index,i])
ranges[i+16,]<-c(min(fifthPool.parm[,i]),max(fifthPool.parm[,i]),fifthPool.parm[bestFitfinal$C5_index,i])
}
rownames(ranges)<-c('r1','k1','x01','input1','r2','k2','x02','input2','r3','k3','x03','input3','r4','k4','x04','input4','r5','k5','x05','input5')
colnames(ranges)<-c('min','max','bestfit')
options(scipen=999)
print(ranges)

write.csv(ranges, file="FivePoolBestFitRanges.csv")
```
